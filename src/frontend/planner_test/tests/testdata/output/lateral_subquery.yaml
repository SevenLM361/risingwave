# This file is automatically generated. See `src/frontend/planner_test/README.md` for more information.
- name: lateral join 1
  sql: |
    create table all_sales (salesperson_id int, customer_name varchar, amount int );
    create table salesperson (id int, name varchar );
    SELECT
    salesperson.name,
    max_sale.amount,
    max_sale_customer.customer_name
    FROM
    salesperson,
    -- calculate maximum size, cache it in transient derived table max_sale
    LATERAL
    (SELECT MAX(amount) AS amount
    FROM all_sales
    WHERE all_sales.salesperson_id = salesperson.id)
    AS max_sale,
    -- find customer, reusing cached maximum size
    LATERAL
    (SELECT customer_name
    FROM all_sales
    WHERE all_sales.salesperson_id = salesperson.id
    AND all_sales.amount =
    -- the cached maximum size
    max_sale.amount)
    AS max_sale_customer;
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchHashJoin { type: Inner, predicate: salesperson.id IS NOT DISTINCT FROM salesperson.id AND all_sales.amount = max(all_sales.amount), output: [salesperson.name, max(all_sales.amount), all_sales.customer_name] }
      ├─BatchHashJoin { type: Inner, predicate: salesperson.id = all_sales.salesperson_id, output: [salesperson.id, salesperson.name, all_sales.customer_name, all_sales.amount] }
      │ ├─BatchExchange { order: [], dist: HashShard(salesperson.id) }
      │ │ └─BatchScan { table: salesperson, columns: [salesperson.id, salesperson.name], distribution: SomeShard }
      │ └─BatchExchange { order: [], dist: HashShard(all_sales.salesperson_id) }
      │   └─BatchScan { table: all_sales, columns: [all_sales.salesperson_id, all_sales.customer_name, all_sales.amount], distribution: SomeShard }
      └─BatchHashAgg { group_key: [salesperson.id], aggs: [max(all_sales.amount)] }
        └─BatchHashJoin { type: LeftOuter, predicate: salesperson.id IS NOT DISTINCT FROM all_sales.salesperson_id, output: [salesperson.id, all_sales.amount] }
          ├─BatchHashAgg { group_key: [salesperson.id], aggs: [] }
          │ └─BatchExchange { order: [], dist: HashShard(salesperson.id) }
          │   └─BatchScan { table: salesperson, columns: [salesperson.id], distribution: SomeShard }
          └─BatchExchange { order: [], dist: HashShard(all_sales.salesperson_id) }
            └─BatchFilter { predicate: IsNotNull(all_sales.salesperson_id) }
              └─BatchScan { table: all_sales, columns: [all_sales.salesperson_id, all_sales.amount], distribution: SomeShard }
  stream_plan: |-
    StreamMaterialize { columns: [name, amount, customer_name, salesperson._row_id(hidden), all_sales._row_id(hidden), salesperson.id(hidden), all_sales.amount(hidden), salesperson.id#1(hidden)], stream_key: [salesperson._row_id, all_sales._row_id, salesperson.id, salesperson.id#1, all_sales.amount], pk_columns: [salesperson._row_id, all_sales._row_id, salesperson.id, salesperson.id#1, all_sales.amount], pk_conflict: NoCheck }
    └─StreamHashJoin { type: Inner, predicate: salesperson.id IS NOT DISTINCT FROM salesperson.id AND all_sales.amount = max(all_sales.amount), output: [salesperson.name, max(all_sales.amount), all_sales.customer_name, salesperson._row_id, all_sales._row_id, salesperson.id, all_sales.amount, salesperson.id] }
      ├─StreamHashJoin { type: Inner, predicate: salesperson.id = all_sales.salesperson_id, output: [salesperson.id, salesperson.name, all_sales.customer_name, all_sales.amount, salesperson._row_id, all_sales._row_id] }
      │ ├─StreamExchange { dist: HashShard(salesperson.id) }
      │ │ └─StreamTableScan { table: salesperson, columns: [salesperson.id, salesperson.name, salesperson._row_id], pk: [salesperson._row_id], dist: UpstreamHashShard(salesperson._row_id) }
      │ └─StreamExchange { dist: HashShard(all_sales.salesperson_id) }
      │   └─StreamTableScan { table: all_sales, columns: [all_sales.salesperson_id, all_sales.customer_name, all_sales.amount, all_sales._row_id], pk: [all_sales._row_id], dist: UpstreamHashShard(all_sales._row_id) }
      └─StreamProject { exprs: [salesperson.id, max(all_sales.amount)] }
        └─StreamHashAgg { group_key: [salesperson.id], aggs: [max(all_sales.amount), count] }
          └─StreamHashJoin { type: LeftOuter, predicate: salesperson.id IS NOT DISTINCT FROM all_sales.salesperson_id, output: [salesperson.id, all_sales.amount, all_sales._row_id] }
            ├─StreamProject { exprs: [salesperson.id] }
            │ └─StreamHashAgg { group_key: [salesperson.id], aggs: [count] }
            │   └─StreamExchange { dist: HashShard(salesperson.id) }
            │     └─StreamTableScan { table: salesperson, columns: [salesperson.id, salesperson._row_id], pk: [salesperson._row_id], dist: UpstreamHashShard(salesperson._row_id) }
            └─StreamExchange { dist: HashShard(all_sales.salesperson_id) }
              └─StreamFilter { predicate: IsNotNull(all_sales.salesperson_id) }
                └─StreamTableScan { table: all_sales, columns: [all_sales.salesperson_id, all_sales.amount, all_sales._row_id], pk: [all_sales._row_id], dist: UpstreamHashShard(all_sales._row_id) }
- name: lateral join 2
  sql: |
    create table all_sales (salesperson_id int, customer_name varchar, amount int );
    create table salesperson (id int, name varchar );
    SELECT
    salesperson.name,
    max_sale.amount,
    max_sale.customer_name
    FROM
    salesperson,
    -- find maximum size and customer at same time
    LATERAL
    (SELECT amount, customer_name
    FROM all_sales
    WHERE all_sales.salesperson_id = salesperson.id
    ORDER BY amount DESC LIMIT 1)
    AS max_sale;
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchHashJoin { type: Inner, predicate: salesperson.id IS NOT DISTINCT FROM all_sales.salesperson_id, output: [salesperson.name, all_sales.amount, all_sales.customer_name] }
      ├─BatchExchange { order: [], dist: HashShard(salesperson.id) }
      │ └─BatchScan { table: salesperson, columns: [salesperson.id, salesperson.name], distribution: SomeShard }
      └─BatchGroupTopN { order: [all_sales.amount DESC], limit: 1, offset: 0, group_key: [all_sales.salesperson_id] }
        └─BatchExchange { order: [], dist: HashShard(all_sales.salesperson_id) }
          └─BatchProject { exprs: [all_sales.salesperson_id, all_sales.amount, all_sales.customer_name] }
            └─BatchFilter { predicate: IsNotNull(all_sales.salesperson_id) }
              └─BatchScan { table: all_sales, columns: [all_sales.salesperson_id, all_sales.customer_name, all_sales.amount], distribution: SomeShard }
  stream_plan: |-
    StreamMaterialize { columns: [name, amount, customer_name, salesperson._row_id(hidden), salesperson.id(hidden), all_sales.salesperson_id(hidden)], stream_key: [salesperson._row_id, all_sales.salesperson_id, salesperson.id], pk_columns: [salesperson._row_id, all_sales.salesperson_id, salesperson.id], pk_conflict: NoCheck }
    └─StreamHashJoin { type: Inner, predicate: salesperson.id IS NOT DISTINCT FROM all_sales.salesperson_id, output: [salesperson.name, all_sales.amount, all_sales.customer_name, salesperson._row_id, salesperson.id, all_sales.salesperson_id] }
      ├─StreamExchange { dist: HashShard(salesperson.id) }
      │ └─StreamTableScan { table: salesperson, columns: [salesperson.id, salesperson.name, salesperson._row_id], pk: [salesperson._row_id], dist: UpstreamHashShard(salesperson._row_id) }
      └─StreamGroupTopN { order: [all_sales.amount DESC], limit: 1, offset: 0, group_key: [all_sales.salesperson_id] }
        └─StreamExchange { dist: HashShard(all_sales.salesperson_id) }
          └─StreamProject { exprs: [all_sales.salesperson_id, all_sales.amount, all_sales.customer_name, all_sales._row_id] }
            └─StreamFilter { predicate: IsNotNull(all_sales.salesperson_id) }
              └─StreamTableScan { table: all_sales, columns: [all_sales.salesperson_id, all_sales.customer_name, all_sales.amount, all_sales._row_id], pk: [all_sales._row_id], dist: UpstreamHashShard(all_sales._row_id) }
- name: lateral join 2 (left join)
  sql: |
    create table all_sales (salesperson_id int, customer_name varchar, amount int );
    create table salesperson (id int, name varchar );
    SELECT
    salesperson.name,
    max_sale.amount,
    max_sale.customer_name
    FROM
    salesperson LEFT JOIN
    -- find maximum size and customer at same time
    LATERAL
    (SELECT amount, customer_name
    FROM all_sales
    WHERE all_sales.salesperson_id = salesperson.id
    ORDER BY amount DESC LIMIT 1)
    AS max_sale on true;
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchHashJoin { type: LeftOuter, predicate: salesperson.id IS NOT DISTINCT FROM all_sales.salesperson_id, output: [salesperson.name, all_sales.amount, all_sales.customer_name] }
      ├─BatchExchange { order: [], dist: HashShard(salesperson.id) }
      │ └─BatchScan { table: salesperson, columns: [salesperson.id, salesperson.name], distribution: SomeShard }
      └─BatchGroupTopN { order: [all_sales.amount DESC], limit: 1, offset: 0, group_key: [all_sales.salesperson_id] }
        └─BatchExchange { order: [], dist: HashShard(all_sales.salesperson_id) }
          └─BatchProject { exprs: [all_sales.salesperson_id, all_sales.amount, all_sales.customer_name] }
            └─BatchFilter { predicate: IsNotNull(all_sales.salesperson_id) }
              └─BatchScan { table: all_sales, columns: [all_sales.salesperson_id, all_sales.customer_name, all_sales.amount], distribution: SomeShard }
  stream_plan: |-
    StreamMaterialize { columns: [name, amount, customer_name, salesperson._row_id(hidden), salesperson.id(hidden), all_sales.salesperson_id(hidden)], stream_key: [salesperson._row_id, all_sales.salesperson_id, salesperson.id], pk_columns: [salesperson._row_id, all_sales.salesperson_id, salesperson.id], pk_conflict: NoCheck }
    └─StreamHashJoin { type: LeftOuter, predicate: salesperson.id IS NOT DISTINCT FROM all_sales.salesperson_id, output: [salesperson.name, all_sales.amount, all_sales.customer_name, salesperson._row_id, salesperson.id, all_sales.salesperson_id] }
      ├─StreamExchange { dist: HashShard(salesperson.id) }
      │ └─StreamTableScan { table: salesperson, columns: [salesperson.id, salesperson.name, salesperson._row_id], pk: [salesperson._row_id], dist: UpstreamHashShard(salesperson._row_id) }
      └─StreamGroupTopN { order: [all_sales.amount DESC], limit: 1, offset: 0, group_key: [all_sales.salesperson_id] }
        └─StreamExchange { dist: HashShard(all_sales.salesperson_id) }
          └─StreamProject { exprs: [all_sales.salesperson_id, all_sales.amount, all_sales.customer_name, all_sales._row_id] }
            └─StreamFilter { predicate: IsNotNull(all_sales.salesperson_id) }
              └─StreamTableScan { table: all_sales, columns: [all_sales.salesperson_id, all_sales.customer_name, all_sales.amount, all_sales._row_id], pk: [all_sales._row_id], dist: UpstreamHashShard(all_sales._row_id) }
- name: lateral join 2 (right join) should throw an error
  sql: |
    create table all_sales (salesperson_id int, customer_name varchar, amount int );
    create table salesperson (id int, name varchar );
    SELECT
    salesperson.name,
    max_sale.amount,
    max_sale.customer_name
    FROM
    salesperson RIGHT JOIN
    -- find maximum size and customer at same time
    LATERAL
    (SELECT amount, customer_name
    FROM all_sales
    WHERE all_sales.salesperson_id = salesperson.id
    ORDER BY amount DESC LIMIT 1)
    AS max_sale on true;
  binder_error: 'Invalid input syntax: The combining JOIN type must be INNER or LEFT for a LATERAL reference.'
